---
name: "Command Injection Vulnerability Fix - CWE-78 Elimination"
description: "Eliminate CWE-78 command injection vulnerability by replacing subprocess.run(shell=True) with safe alternatives using shlex.split() and shell=False"
prp_id: "PRP-22"
status: "executed"
created_date: "2025-10-19T12:00:00Z"
last_updated: "2025-10-19T18:00:00Z"
updated_by: "claude-code-execution"
priority: "CRITICAL"
complexity: "medium"
estimated_hours: "4-6"
risk_level: "MEDIUM"
security_level: "CRITICAL"
cwe_ids: ["CWE-78"]
cvss_score: "8.1"
cvss_severity: "HIGH"
context_sync:
  ce_updated: true
  serena_updated: false
  last_sync: "2025-10-19T18:00:00Z"
  validation_status: "PASS"
  test_coverage: "38/38 security tests"
  regression_status: "PASS (631 tests)"
  shell_true_remaining: 0
dependencies:
  - "subprocess module (Python stdlib)"
  - "shlex module (Python stdlib)"
  - "pytest (testing framework)"
related_prp: []
version: 1
---

# PRP-22: Eliminate Command Injection Vulnerability (CWE-78)

## ğŸ¯ TL;DR

**Problem**: Critical command injection vulnerability in `run_cmd()` function (tools/ce/core.py:35) uses `subprocess.run(cmd, shell=True)` allowing arbitrary command execution via unsanitized input.

**Security Impact**: 
- CVSS 8.1 (HIGH)
- CWE-78: Improper Neutralization of Special Elements in OS Command
- Attack Vector: `run_cmd(f"cat {user_input}")` with `user_input = "file.md; rm -rf /"`
- Result: Execution of arbitrary commands with application privileges

**Solution**: Replace `shell=True` with `shell=False` + `shlex.split()` to eliminate shell interpretation. Add Python helper functions to replace shell pipelines (git ls-files | wc -l, git diff | wc -l).

**Impact**:
- âœ… Eliminates CWE-78 attack surface completely
- âœ… CVSS reduction: 8.1 â†’ 0 (vulnerability eliminated)
- âœ… Backward compatible: `run_cmd()` still accepts strings
- âœ… Improves code clarity (explicit list format vs implicit shell)
- âœ… No performance regression (shlex is fast, saves shell spawning)

**Effort**: 4-6 hours (implementation, testing, verification)

**Risk**: MEDIUM - Standard library functions, low complexity, comprehensive test coverage mitigates risk

**Success Criteria**:
- âœ… Zero `shell=True` usage in codebase
- âœ… All security tests pass (injection prevention)
- âœ… All existing tests pass (no regression)
- âœ… Command injection vulnerability verified eliminated

---

## ğŸ“– Context

### Background: CWE-78 Command Injection Vulnerability

**CWE-78** is categorized as "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')" by MITRE. It represents one of the most critical security vulnerabilities in software development.

**Official Sources**:
- [CWE-78 Definition](https://cwe.mitre.org/data/definitions/78.html) - MITRE/NIST
- [CISA: Secure Design Alert - Eliminating OS Command Injection](https://www.cisa.gov/resources-tools/resources/secure-design-alert-eliminating-os-command-injection-vulnerabilities)
- [Bandit B602 Security Check](https://bandit.readthedocs.io/en/latest/plugins/b602_subprocess_popen_with_shell_equals_true.html)

**Why shell=True is Dangerous**:

When `shell=True` is used with `subprocess.run()`, the command must be formatted as a shell command string. The shell then processes this string, interpreting shell metacharacters (`; | > < $ () \`` etc.) before executing.

If any part of this string comes from user input or dynamic sources, an attacker can inject additional commands:

```python
# VULNERABLE
user_input = "file.md; rm -rf /"
run_cmd(f"cat {user_input}")
# Executes: cat file.md; rm -rf /
# Result: File listed, then filesystem deleted!
```

**Current Vulnerability in tools/ce/core.py**:

```python
# Line 35 - VULNERABLE
result = subprocess.run(
    cmd,              # User-controlled string
    shell=True,       # âŒ DANGEROUS
    cwd=cwd,
    timeout=timeout,
    capture_output=capture_output,
    text=True
)
```

### Current Codebase Analysis

**Vulnerable Patterns** (6 locations):

1. **Core `run_cmd()` function** - `tools/ce/core.py:35`
   - Type: Direct `shell=True` usage
   - Risk: Direct command injection surface
   - Scope: All callers of `run_cmd()` affected

2. **Shell pipelines in context.py** (5 locations):
   - Line 32: `git ls-files | wc -l` (count tracked files)
   - Line 552: `git ls-files | wc -l` (calculate drift score)
   - Line 573-574: `git diff HEAD~5 -- ... 2>/dev/null | wc -l` (dependency changes)
   - Line 637: `git ls-files | wc -l` (context health)
   - Line 662-663: `git diff HEAD~5 -- ... 2>/dev/null | wc -l` (dependency changes)
   - Type: Shell pipelines with pipes and redirections
   - Risk: Inherent in `run_cmd()` with `shell=True`
   - Solution: Replace with Python equivalents

**Safe Patterns Already in Use** (examples to maintain):

- `tools/ce/markdown_lint.py:27, 55` - Uses list format
  ```python
  check_cmd = ["which", "markdownlint-cli2"]  # âœ… SAFE
  result = subprocess.run(check_cmd, shell=False, capture_output=True)
  ```

**Codebase Context**:
- Test files use `subprocess.run` in test fixtures (44 test files)
- No existing `shlex` imports in `run_cmd()` (though `shlex` used elsewhere in core.py:357)
- No existing command injection tests
- Baseline: 100% test pass rate (must maintain)

### Recommended Mitigation Strategy

**Industry Best Practice** (per CISA, Bandit, Semgrep):

1. **Never use `shell=True`** - Default to `shell=False`
2. **Pass commands as lists** - `subprocess.run(["cmd", "arg1", "arg2"], shell=False)`
3. **Use `shlex.split()` for strings** - If string parsing needed:
   ```python
   import shlex
   cmd_list = shlex.split(cmd_string)
   subprocess.run(cmd_list, shell=False)
   ```
4. **Quote user input** - If constructing commands: `shlex.quote(user_input)`
5. **Validate input** - Restrict to expected formats

**Our Implementation Approach**:
- Refactor `run_cmd()` to accept both strings (via `shlex.split()`) and lists
- Maintain backward compatibility (existing callers work unchanged)
- Add helper functions to replace shell pipelines
- Create comprehensive security tests

---

## ğŸ”§ Implementation Steps

### Phase 1: Refactor run_cmd() Function (1 hour)

**File**: `tools/ce/core.py:8-68`

**Current State**: Lines 8-68 use `shell=True`

**Changes**:

1. Add import at top of file:
   ```python
   import shlex
   ```

2. Update function signature to accept `Union[str, List[str]]`:
   ```python
   def run_cmd(
       cmd: Union[str, List[str]],  # NOW accepts both
       cwd: Optional[str] = None,
       timeout: int = 60,
       capture_output: bool = True
   ) -> Dict[str, Any]:
   ```

3. Add safe string parsing logic:
   ```python
   # Convert string to safe list
   if isinstance(cmd, str):
       cmd_list = shlex.split(cmd)  # Parse safely
   else:
       cmd_list = cmd
   
   # Handle empty command
   if not cmd_list:
       raise ValueError(
           "Empty command provided\n"
           "ğŸ”§ Troubleshooting: Provide a valid command string or list"
       )
   ```

4. Replace `shell=True` with `shell=False`:
   ```python
   result = subprocess.run(
       cmd_list,       # âœ… Use list format
       shell=False,    # âœ… SAFE - no shell interpretation
       cwd=cwd,
       timeout=timeout,
       capture_output=capture_output,
       text=True
   )
   ```

5. Update error messages to show command list:
   ```python
   # In TimeoutError:
   f"Command timed out after {timeout}s: {' '.join(cmd_list)}\n"
   
   # In RuntimeError:
   f"Command failed: {' '.join(cmd_list)}\n"
   ```

**Validation**: Run test suite to confirm backward compatibility
```bash
cd tools && uv run pytest tests/test_core.py::test_run_cmd_success -v
cd tools && uv run pytest tests/test_core.py::test_run_cmd_failure -v
```

### Phase 2: Add Helper Functions (1 hour)

**File**: `tools/ce/core.py` (after `run_cmd()` function)

**Purpose**: Replace shell pipelines with Python equivalents to avoid shell entirely

**New Function 1: count_git_files()**

```python
def count_git_files() -> int:
    """Count total tracked files in git repository.
    
    Replaces shell pattern: git ls-files | wc -l
    
    Returns:
        Number of tracked files
    
    Raises:
        RuntimeError: If not in git repository
    
    Note: Uses subprocess.run with shell=False for safety.
    """
    try:
        result = subprocess.run(
            ["git", "ls-files"],
            capture_output=True,
            text=True,
            shell=False,  # âœ… SAFE
            timeout=30
        )
        
        if result.returncode != 0:
            raise RuntimeError(
                "Failed to list git files\n"
                "ğŸ”§ Troubleshooting: Ensure you're in a git repository"
            )
        
        # Count lines in Python (no shell pipe needed)
        files = result.stdout.strip().split('\n') if result.stdout.strip() else []
        return len(files)
        
    except subprocess.TimeoutExpired:
        raise RuntimeError(
            "Git ls-files timed out\n"
            "ğŸ”§ Troubleshooting: Repository may be too large"
        )
```

**New Function 2: count_git_diff_lines()**

```python
def count_git_diff_lines(
    ref: str = "HEAD~5",
    files: Optional[List[str]] = None
) -> int:
    """Count lines changed in git diff.
    
    Replaces shell pattern: git diff HEAD~5 -- file1 file2 | wc -l
    
    Args:
        ref: Git reference to diff against (default: HEAD~5)
        files: Optional list of files to diff
    
    Returns:
        Number of changed lines
    
    Note: Returns 0 on error (graceful degradation for health checks).
    """
    cmd = ["git", "diff", ref]
    if files:
        cmd.extend(["--"] + files)
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            shell=False,  # âœ… SAFE
            timeout=30
        )
        
        if result.returncode != 0:
            return 0  # No changes or error
        
        # Count lines in Python
        return len(result.stdout.split('\n')) if result.stdout else 0
        
    except subprocess.TimeoutExpired:
        return 0  # Graceful timeout handling
```

**Validation**: Test helper functions
```bash
cd tools && uv run pytest tests/test_core.py::test_count_git_files -v
cd tools && uv run pytest tests/test_core.py::test_count_git_diff_lines -v
```

### Phase 3: Update context.py - Replace Shell Pipelines (1.5 hours)

**File**: `tools/ce/context.py`

**Step 1: Add imports** (at top of file, after existing imports)
```python
from .core import count_git_files, count_git_diff_lines
```

**Step 2: Line 32** - Replace shell pipeline in `sync()` function

OLD (vulnerable):
```python
total_result = run_cmd("git ls-files | wc -l", capture_output=True)
if not total_result["success"]:
    raise RuntimeError("Failed to count tracked files: ...")
total_files = int(total_result["stdout"].strip())
```

NEW (safe):
```python
total_files = count_git_files()
```

**Step 3: Line 552** - Replace in `calculate_drift_score()` function

OLD (vulnerable):
```python
total_result = run_cmd("git ls-files | wc -l", capture_output=True)
if total_result["success"]:
    total_files = int(total_result["stdout"].strip())
else:
    total_files = 0
```

NEW (safe):
```python
try:
    total_files = count_git_files()
except RuntimeError:
    total_files = 0  # Graceful fallback
```

**Step 4: Line 573-574** - Replace dependency check in `calculate_drift_score()`

OLD (vulnerable):
```python
deps_result = run_cmd(
    "git diff HEAD~5 -- pyproject.toml package.json 2>/dev/null | wc -l",
    capture_output=True
)
if deps_result["success"]:
    deps_lines = int(deps_result["stdout"].strip())
```

NEW (safe):
```python
deps_count = count_git_diff_lines(
    ref="HEAD~5",
    files=["pyproject.toml", "package.json"]
)
```

**Step 5: Line 637** - Replace in `context_health_verbose()` function (same as Step 3)

**Step 6: Line 662-663** - Replace in `context_health_verbose()` function (same as Step 4)

**Validation**: Test context functions
```bash
cd tools && uv run pytest tests/test_context.py -v
```

### Phase 4: Create Comprehensive Security Tests (1-1.5 hours)

**File**: `tools/tests/test_security.py` (create new)

**Purpose**: Verify command injection is prevented and shell metacharacters are safely escaped

```python
import pytest
from ce.core import run_cmd, count_git_files, count_git_diff_lines


class TestCommandInjectionPrevention:
    """Tests for CWE-78 command injection vulnerability prevention."""
    
    def test_run_cmd_rejects_command_chaining(self):
        """Command chaining (;) should fail, not execute both commands."""
        result = run_cmd("ls; whoami")
        assert result["success"] is False
        assert "root" not in result["stderr"].lower() and "root" not in result["stdout"].lower()
    
    def test_run_cmd_rejects_pipe_injection(self):
        """Pipes (|) should be treated as literal arguments, not shell operators."""
        result = run_cmd("echo test | cat")
        assert result["success"] is False
    
    def test_run_cmd_rejects_redirection(self):
        """Output redirection (>) should be treated as literal arguments."""
        result = run_cmd("echo test > /tmp/injection_test")
        assert result["success"] is False
    
    def test_run_cmd_rejects_backtick_substitution(self):
        """Backtick command substitution (`) should be literal."""
        result = run_cmd("echo `whoami`")
        assert result["success"] is False
    
    def test_run_cmd_rejects_dollar_substitution(self):
        """Dollar command substitution ($(...)) should be literal."""
        result = run_cmd("echo $(whoami)")
        assert result["success"] is False
    
    def test_run_cmd_with_valid_list_format(self):
        """List format should work correctly."""
        result = run_cmd(["echo", "test"])
        assert result["success"] is True
        assert "test" in result["stdout"]
    
    def test_run_cmd_with_quoted_string(self):
        """Quoted strings should be parsed correctly by shlex."""
        result = run_cmd("echo 'hello world'")
        assert result["success"] is True
        assert "hello world" in result["stdout"]
    
    def test_run_cmd_empty_string_raises_error(self):
        """Empty string should raise ValueError."""
        with pytest.raises(ValueError, match="Empty command"):
            run_cmd("")
    
    def test_run_cmd_empty_list_raises_error(self):
        """Empty list should raise ValueError."""
        with pytest.raises(ValueError, match="Empty command"):
            run_cmd([])
    
    def test_count_git_files_no_injection(self):
        """count_git_files() should be injection-proof."""
        count = count_git_files()
        assert isinstance(count, int)
        assert count >= 0
    
    def test_count_git_diff_lines_safe(self):
        """count_git_diff_lines() should handle edge cases safely."""
        count = count_git_diff_lines("HEAD~1")
        assert isinstance(count, int)
        assert count >= 0


class TestBackwardCompatibility:
    """Tests to ensure backward compatibility with existing code."""
    
    def test_run_cmd_accepts_string(self):
        """run_cmd() should still accept string format."""
        result = run_cmd("echo backward_compat")
        assert result["success"] is True
        assert "backward_compat" in result["stdout"]
    
    def test_run_cmd_accepts_list(self):
        """run_cmd() should accept list format."""
        result = run_cmd(["echo", "list_format"])
        assert result["success"] is True
        assert "list_format" in result["stdout"]
    
    def test_run_cmd_return_format_unchanged(self):
        """Return dict format should remain unchanged."""
        result = run_cmd("echo test")
        assert "success" in result
        assert "stdout" in result
        assert "stderr" in result
        assert "exit_code" in result
        assert "duration" in result
```

**Validation**: Run security tests
```bash
cd tools && uv run pytest tests/test_security.py -v
```

---

## âœ… Validation Gates

### Pre-Implementation Gate

- [x] Code review identifies vulnerability location
- [x] Replacement strategy validated (shlex + shell=False)
- [x] Test plan documented
- [x] Security impact assessment complete

### During Implementation Gate

- [ ] **Gate 1: run_cmd() Refactoring** - `cd tools && uv run pytest tests/test_core.py::test_run_cmd_success -v` - PASS
- [ ] **Gate 2: Helper Functions** - `cd tools && uv run pytest tests/test_core.py -k "count_git" -v` - PASS
- [ ] **Gate 3: context.py Updates** - `cd tools && uv run pytest tests/test_context.py -v` - PASS
- [ ] **Gate 4: Security Tests** - `cd tools && uv run pytest tests/test_security.py -v` - PASS

### Post-Implementation Gate

- [ ] **Full Regression Test** - `cd tools && uv run pytest tests/ -v` - PASS (all 44 files)
- [ ] **Manual Security Verification** - No shell=True in codebase
- [ ] **Code Review** - Approved

---

## ğŸ§ª Testing Strategy

### Security Testing (test_security.py)
- Command chaining prevention (;)
- Pipe operator handling (|)
- Redirection safety (>)
- Command substitution (backticks, dollar syntax)
- Empty command handling

### Functional Testing (test_core.py updates)
- String format backward compatibility
- List format support
- Quoted string parsing
- Helper function correctness
- Error handling

### Integration Testing (test_context.py updates)
- sync() function correctness
- calculate_drift_score() uses helpers
- context_health_verbose() uses helpers

---

## ğŸ“Š Rollout Plan

### Phase 1: Development (2-3 hours)
1. Refactor run_cmd()
2. Implement helpers
3. Update context.py
4. Create security tests

### Phase 2: Review (30 min)
1. Code review
2. Security audit
3. Backward compat verification

### Phase 3: Deployment (15 min)
1. Merge to main
2. Verify CI/CD passes
3. Tag release

---

## ğŸ” Security Impact

**Before**: CVSS 8.1 (HIGH) - CWE-78 Critical Vulnerability  
**After**: CVSS 0 - Vulnerability Eliminated  
**Confidence**: 10/10

**Generated by**: `/generate-prp` command  
**Status**: Ready for execution
